/*********************************************************************************
 * Copyright (c) 2006-2012 Forschungszentrum Juelich GmbH 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * (1) Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer at the end. Redistributions in
 * binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * 
 * (2) Neither the name of Forschungszentrum Juelich GmbH nor the names of its 
 * contributors may be used to endorse or promote products derived from this 
 * software without specific prior written permission.
 * 
 * DISCLAIMER
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ********************************************************************************/
 
package eu.unicore.services.ws.security;

import java.lang.reflect.Method;

import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.logging.log4j.Logger;

import de.fzj.unicore.wsrflite.Home;
import de.fzj.unicore.wsrflite.Kernel;
import de.fzj.unicore.wsrflite.impl.ResourceImpl;
import de.fzj.unicore.wsrflite.security.SecurityManager;
import de.fzj.unicore.wsrflite.security.pdp.ActionDescriptor;
import de.fzj.unicore.wsrflite.security.pdp.UnicoreXPDP;
import de.fzj.unicore.wsrflite.security.util.AuthZAttributeStore;
import de.fzj.unicore.wsrflite.security.util.ResourceDescriptor;
import eu.unicore.security.AuthorisationException;
import eu.unicore.security.Client;
import eu.unicore.security.OperationType;
import eu.unicore.security.SecurityTokens;
import eu.unicore.security.wsutil.AuthInHandler;
import eu.unicore.security.wsutil.CXFUtils;
import eu.unicore.services.ws.cxf.CXFKernel;
import eu.unicore.services.ws.cxf.WSRFHandler;
import eu.unicore.services.ws.cxf.WSRFInvoker;
import eu.unicore.util.Log;

/**
 * A handler for authorising access to both plain and WSRF services.
 * 
 * This handler relies on security tokens being present in the message context,
 * for example as generated by the {@link AuthInHandler}.
 * 
 * For plain WS, these {@link SecurityTokens} and the {@link Client} object will be placed into 
 * thread-local storage in {@link AuthZAttributeStore}, so the service can later retrieve them. 
 * 
 * @author schuller
 * @author golbi
 */
public class AccessControlHandler extends AbstractSoapInterceptor{
	
	private static final Logger logger=Log.getLogger(Log.SECURITY,AccessControlHandler.class);

	private final Kernel kernel;
	private final SecurityManager securityManager;
	
	public AccessControlHandler(Kernel kernel) {
		super(Phase.PRE_INVOKE);
		this.kernel=kernel;
		this.securityManager=kernel.getSecurityManager();
		
		getAfter().add(AuthInHandler.class.getName());
		getAfter().add(WSRFHandler.class.getName());
		logger.debug("Initialising security infrastructure.");
		boolean checking=kernel.getContainerSecurityConfiguration().isAccessControlEnabled();
		if(!checking){
			logger.debug("WSRF access control disabled.");
			return;
		}
		UnicoreXPDP pdp=kernel.getContainerSecurityConfiguration().getPdp();
		logger.info("WS(RF) access control enabled using <"+pdp.getClass().getName()+">");
	}

	@Override
	public void handleMessage(SoapMessage ctx){
		String serviceName=CXFKernel.getSimpleServiceName(ctx);
		if(serviceName==null)throw new IllegalStateException("No service defined in message exchange");
		if(!isCheckingService(serviceName) || CXFUtils.isLocalCall(ctx))return;
		
		Home home=kernel.getHome(serviceName);
		if(home==null){
			checkAccessPlainWS(ctx, serviceName);
		}
		else{
			checkAccessWSRF(ctx,serviceName);
		}
		
	}
	
	protected void checkAccessPlainWS(Message ctx, String serviceName){
		ResourceDescriptor resourceDescriptor=null;
		Client client=null;
		String action=getAction(ctx);
		try{
			client=createClient(ctx);
			String owner = kernel.getContainerSecurityConfiguration().getCredential().
					getSubjectName();
			resourceDescriptor=new ResourceDescriptor(serviceName,null,owner);
		} catch(Exception e){
			Log.logException("Error setting up authorisation check",e,logger);
			AuthZAttributeStore.removeClient();
			throw new AuthorisationException("Authorisation failed. Reason: "+e.getMessage());
		}
		doCheck(client, action, OperationType.modify, resourceDescriptor);
	}
	
	protected void checkAccessWSRF(Message context, String serviceName) {
		ResourceDescriptor resourceDescriptor=null;
		Client client=null;
		String action=getAction(context);

		Object target=context.getExchange().get(WSRFInvoker.KEY);
		if(target==null)throw new IllegalStateException("No service instance!");
		
		OperationType opType = getActionType(serviceName, context);
		
		try{
			ResourceImpl resource=(ResourceImpl)target;
			SecurityTokens securityTokens = (SecurityTokens)context.get(SecurityTokens.KEY);
			if (securityTokens != null){
				resource.updateSecurityTokensBeforeAIP(securityTokens);
			}
			client = createClient(context);
			resourceDescriptor = securityManager.checkACL(client, opType, resource);
		} catch(Exception e) {
			String msg=Log.createFaultMessage("Error setting up access control check: "+e.getMessage(), e);
			logger.warn(msg,e);
			AuthZAttributeStore.removeClient();
			//some error, we interpret this as "failed"
			throw new AuthorisationException(msg,e);
		}
		doCheck(client, action, opType, resourceDescriptor);
	}
	
	/**
	 * gets the XACML action, which is either the method name 
	 * or the SOAP action
	 */
	protected String getAction(Message message){
		Method m=CXFUtils.getMethod(message);
		if(m!=null){
			return m.getName();
		}
		else{
			return CXFUtils.getAction(message);
		}
	}
	
	protected Client createClient(Message context) {
		SecurityTokens securityTokens = (SecurityTokens)context.get(SecurityTokens.KEY);
		if (securityTokens == null)
			throw new AuthorisationException("Security check can't be performed as no security " +
					"tokens are present. Probably the server is misconfigured.");
		Client client = securityManager.createClientWithAttributes(securityTokens);

		AuthZAttributeStore.setClient(client);
		return client;
	}
	
	/**
	 * perform the actual check

	 * @param client - the current client 
	 * @param action - the action
	 * @param actionType - the action type, e.g. 'modify' 
	 * @param rd - the resource
	 */
	protected void doCheck(Client client, String action, OperationType actionType, ResourceDescriptor rd){
		SecurityTokens securityTokens = client.getSecurityTokens();

		if (!securityTokens.isConsignorTrusted())
			throw new AuthorisationException("Consignor is trying to invoke " +
				"an operation on User's behalf without trust delegation from the User.");
		
		if(logger.isDebugEnabled())logger.debug("Checking access on service "+rd);

		//do not check server-scope (internal) use of the resources
		if(securityManager.isServer(client) ){
			if(logger.isDebugEnabled())logger.debug("Accept server-scope action <"+action+"> on "+rd);
			return;
		}
		
		//check signature status
		securityManager.getSignatureChecker().
			checkDigitalSignature(securityTokens,action,rd);

		//finally check resource access: this will throw an 
		//AuthorisationException if access is not permitted
		securityManager.checkAuthorisation(client, new ActionDescriptor(action, actionType), rd);
		
		//collect dynamic attributes
		securityManager.collectDynamicAttributes(client);
	}
	
	private OperationType getActionType(String serviceName, Message message) {
		Method method=CXFUtils.getMethod(message);
		String mName=method!=null?method.getName():null;
		return securityManager.getOperationTypesUtil().getOperationType(serviceName, mName);
	}

	public boolean isCheckingService(String serviceName){
		return kernel.getContainerSecurityConfiguration().isAccessControlEnabled(serviceName);
	}

}
